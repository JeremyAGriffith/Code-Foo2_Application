3)  You own a license plate manufacturing company. Write a program that takes a population and determines the simplest pattern that will produce enough unique plates. Since all the plates that match the pattern will be generated, find the pattern that produces the least excess plates. Use a combination of letters (A-Z) and numbers (0-9).

I started this problem by writing out the patterns in order of increasing possibilities using a “#” symbol for numbers and “A” for letters.  Adding a number to a pattern multiplies the current possibilities by 10 and a letter multiplies by 26.  Upon reaching patterns containing four entries, I realized that there was no apparent set of rules being followed.  I also noticed that aside from simply increasing the amount of letters or numbers, there were two unique instances of complexity occurring.

First, I could allow any entry of a pattern to be a letter, number, or either a letter or number.  This means that the extra possibilities to be multiplied would be 36 in the “either” case.  For this special case I used the “@” for denoting an entry which can be either a number or letter.

The second complexity occurred when I arrived at patterns with 2 entries.  I found that combinations of single patterns could be put together, creating unique possibility totals falling in between the simple adding of numbers and letters.  To illustrate a combination, I will move through patterns with two entries.
     # # – 100 possibilities
     #A – 260
     #@ – 360
     Combination of  A# [AND] #A – 260 + 260 = 520 
     AA – 676
By using a combination of two single patterns (#A [AND] A#), in this case both with 260 possibilities, another plausible pattern has been created with 520 plates.  This combination has no redundancy, so it seems perfectly acceptable.

The first unique case of the “@” symbol, either a letter or number, seemed reasonably easy to account for.  The solution that came to mind was recursion due to a three-root tree visualization I saw when writing out the patterns.  The program could recurse each time trying all three entry types: #, A, @.  When it had created all possible patterns that accommodated the given population, it would pick the one that had the smallest number of possibilities, least excess.

It was good . . . but I was still haunted by the second complexity I came across.  Sure the single patterns being offered up were the “simplest patterns” asked in the question, but what if the owner of this company is a real penny-pincher.  “405 excess plates !” says he, “That's comin' out of yer pay.”  I don't have that kind of money.  So I have attempted to create a program that also tries to find a combination of single patterns that when ALL manufactured will produce less excess than the best single pattern.  I saw how infinitely nasty combining any two or more single patterns could be, so I placed my own arbitrary rule of “A legal combination must contain two or more patterns, and all patterns used must have the same number of entries with no redundancy.”  An example of a legal combination is (##A [AND] #AA) and an unacceptable combination would be (##AA [AND] #A) because the patterns it contains do not have the same number of entries.  Due to the redundancy factor, I didn't allow the either case “@” in any combinations.

I chose to implement my program in the Frink programming language found @ http://futureboy.us/frinkdocs/.  Frink works on PC, Mac, Linux, and most uniquely Android.  As an Android smartphone user myself, I have known about the Frink app in Google's Play Store for a while now.  I decided to download it and learn Frink's syntax as a fun way to tackle the problem.  I wrote and built the entire program on my LG Spectrum, so naturally it has very real limitations for how many recursive functions can be on the stack at any one time.  For this reason, I allow the user to select if they want to find a solution that has the least possible excess license plates, which might be a combination of two or more single patterns, or if they only want to have a single pattern, which my contain more excess.  On my phone, the combination answer can only handle a population of around < 18000, whereas the single pattern allows for a population of over 1 million.  I thoroughly enjoyed learning another language for this task.
